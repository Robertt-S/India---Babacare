==================== Setup ====================
Criar um enviroment:
    py -m venv venv

Ativar enviroment
    source venv/Scripts/activate
    source venv/bin/activate
    .\venv\Scripts\activate

    deactivate

    npm init
    npm i bootstrap@5.3.3

Instalar os recurso
    py -m pip install Django
    (pode atualizar o pip se quiser)

Criar um projeto
    django-admin startproject setup <-- nome do projeto

    cd setup

    py manage.py runserver

==================== Comandos Server ====================

Dentro do env, PARA INICIAR O SERVER
    py manage.py runserver
    (clique no ip do server segurando Ctrl)
    ctrl+c no terminal para cessar o server

==================== urls.py ====================

    Neste arquivo dentro de urlpatterns, cada "path" colocado ser√° um sufixo
adicionado ao final do ip do server. Por exemplo:
        http://127.0.0.1:8000/ √© a home
        http://127.0.0.1:8000/about/ √© o sobre do site
        etc

    no m√©todo path, s√£o passados 2 argumento:
    path( 'sufixo do ip', m√©todo que ser√° chamado quando acessado o ip com sufixo ). 
Exemplo:
    path('about/', views.about), 
    (quando acessado http://127.0.0.1:8000/about/, um m√©todo no arquivo views ser√° chamado
    que far√° o processo de quando acessar o ip, "request")

==================== views.py ====================

   Os m√©todos contidos nessa classe s√£o as respostas de quando o usu√°rio
acessa o ip com sufixo.

    def homepage(request):
    #return HttpResponse('Hello World! I\'m home')
    return render(request, 'home.html')

    no primeiro return (comentado), se o user acessa o ip, ele s√≥ ver√° uma mensagem
    no segundo return, quando acessado a home do site, o arquivo html √© acessado, assim
ele √© mandado para um template do site

==================== Templates ====================

    Aqui est√£o os arquivos html que funcionam como o front-end do site, aquilo que o 
usu√°rio ver√°

==================== Templates ====================
HTML

    <title></title> - o que estiver escrito neste bloco aparece na aba do site (l√° em cima)
    <link rel="stylesheet" href="{% static 'css/style.css'%}"> - refer√™ncia de onde
o arquivo html tira as informa√ß√µes sobre o estilo da p√°gina
    <h1></h1> - mensagem que aparecer√° (n√£o necess√°riamente tem que ser h1, neste caso 
foram usadas a vari√°veis h1 e p, para escrever no site [ <p></p> ])

Exemplo:
    'nav' e 'a' s√£o vari√°veis
    onde nav √© um local definido onde vai aparecer coisas definidas por 'a'
    e 'a' √© um bot√£o por conta de "href" q direciona para home, about e posts
    o que est√° dentro do bloco <a></a> aparecer√° no site como um bot√£o
    <nav>
        <a href="/">üè†</a> | 
        <a href="/about">üòÅ</a> |
        <a href="/posts">üì∞</a>
    </nav>

    Para que tudo seja usado, o Django tem uma √°rea no arquivo "setup/setting.py" que far√°
refer√™ncia √† pasta de templates. Na √°rea "TEMPLATES" depois em DIRS[]

CSS
    ctrl + f5 para atualizar mudan√ßas no style.css
==================== Static ====================

    Neste diret√≥rio estar√£o arquivos est√°ticos, isto √©, arquivos que n√£o sofrer√£o mudan√ßas
a n√£o ser que por desejo do admin ou do programador do app. Estilos da p√°gina, frases ou
fontes de texto

    Para o Django reconhecer estes arquivos, no arquivo "setup/setting.py", ap√≥s "STATIC_URL",
foi criado uma lista de diret√≥rios, para o Django reconhecer,(STATICFILES_DIRS)

    {% load static %} √© adicionado aos arquivos html para "puxar" as informa√ß√µes dos arquivos 
"est√°ticos".  Por isso no block <link></link> o href, referencia {%static 'nome do arquivo'%}

==================== Posts ====================

    Apps s√£o peda√ßos de um projeto, com o intuito de diminuir a complexidade do projeto,
tipo SCRUM basicamente, mas em c√≥digo. Eles s√£o modulares, isto √©, ele s√£o como, literal,
pe√ßas, ent√£o √© poss√≠vel copiar o app de um projeto para o outro, ele funcionam independen-
mente.

py manage.py startapp 'nome do app'

[em setup/settings]
    na parte de INSTALLED_APPS, incluir 'nomedoapp', para q o django reconhe√ßa mudan√ßas
na main setup e nos apps

referencia o views.py do setup
    [em posts/urls.py]
        path('', views.posts_list),
bota um link(sufixo) para posts
    [em setup/url.py]
        path('posts/', include('posts.urls'))

    include fala para o Django olhar dentro da pasta posts, 
e ver os urls dentro do arquivo urls.py

[em posts/views.py]
referencia os templates de posts
    def posts_list(request):
        return render(request, 'posts/posts_list.html')

==================== layout.html ====================

    Este arquivo funciona como template para outros html
    Funciona, de certa forma, como um interface e implementa√ß√£o, em Orienta√ß√£o
Orientada √† Objetos

[em layout.html]
    {% block title %}
            Django App
    {% endblock %}

    Este bloco tem nome de title e termina em endblock, entre essas linhas, "Django App"
aparecer√° por defini√ß√£o, caso n√£o seja alterado

[em home.html]
    {% extends 'layout.html' %} diz que o arquivo "implementa/extende" layout.html

    {%block title%}
        Home            substitui no layout.html
    {%endblock%}

==================== models.py ====================

    Models modelam informa√ß√µes e cada informa√ß√£o ter√° uma coluna na base de dados
    Classes --(migrate)-> colunas na base de dados

    class Post(models.Model):
    title = models.CharField(max_length=75)     t√≠tulo do post
    body = models.TextField()                   √°rea de input de texto
    slug = models.SlugField()                   sufixo ap√≥s posts (http.../posts/'slug')
    date = models.DateField(auto_now_add=True)  data do post (quando postado, automatico dia e data)

1 - migrar os models padr√µes do Django
    py manage.py migrate

2 - migrar o model criado
    py manage.py makemigrations
    (Serve tamb√©m para atualizar os models)
    
A√≠ ele cria a migration, no posts/migration/numeroDaMigra√ß√£o.py
Manda para o banco de dados
    py manage.py migrate

M√©todos criados no model, na classe, n√£o precisam migrar

========================================

ORM - Object Relational Mapping
    Intermediador do c√≥digo python e do banco de dados

Para abrir o menu interativo
    py manage.py shell
    from posts.models import Post

Cria uma instancia de Post
    p = Post()
Seta um titulo e salva no BD
    p.title = "My First Post!"
    p.save()
    Post.objects.all() - quantos objetos no BD
    Post.objects.all().delete() - limpa o BD

Para sair
    exit()

==================== Django Admin ====================

Acesse o site mas com o sufixo "/admin/"
    path('admin/', admin.site.urls),

Criar username e password (superUser)
    py manage.py createsuperuser

    Username (leave blank to use 'pc'): [coloque um username]
    Email address: [n√£o precisa colocar email, s√≥ d√™ ENTER]
    Password: [A senha deve ter 8 caracteres]

==================== admin.py ====================

    Neste arquivo estar√£o itens que gostariamos de ver no 'admin/', basta apenas
registrar os models
    admin.site.register(Post) -> no lugar de Post coloca-se o nome do model criado

[em posts/views.py]
    Passamos todos os posts para o html, usando a fun√ß√£o em views

[em posts_list.hmtl]
    √© feito um for para cada Post no BD 
    <article></article> - √© uma variavel que pode repetir basicamente
    tem um class="post", para futuramente adicionar um style para o post

    <h2> vai receber o t√≠tulo do post
    <p> 'par√°grafo' recebe a data e o texto do post (body)

==================== adicionando sufixos / SLUGS ====================

[em posts/urls.py]
Dando nome aos urls
    path('', views.posts_list, name="posts"),

[em layout.html]
    <a href="{% url 'posts' %}">üì∞</a>

    Estamos passando como referencia o nome dos urls posts no posts/urls.py,
href = "Eu quero como refer√™ncia..."
url = "esse url..."
'posts' = "que tem esse nome"

========================================

[em posts/urls.py]
Path converters
    path('<slug:slug>', views.post_page, name="page"),
<slug: slug> - 1¬∫ slug √© o path converter e nesse caso o par√¢metro √© slug tamb√©m, o nome do atributo da classe Post
post_page - m√©todo que vai ser criado em views.py
page - √© o nome do url

[em posts/views.py]
    def post_page(request, slug):
      return HttpResponse(slug)
Para fazer o teste se quando a url √© acessada, o slug √© printado no console do site

[em posts/templates/posts_list.html]
    em <h2>{{ post.title }}</h2> queremos passar um link em vez do titulo

    <h2>
        <a href="{% url 'page' slug=post.slug %}">
            {{ post.title }}
        </a>
    </h2>

    portanto passamos uma referencia √† url 'page' citada em urls.py e o slug do objeto post

[em posts/urls.py]
    #esses urls est√£o dentro do app posts
    app_name = 'posts'

Assim quando os urls dos posts s√£o chamados, devemos usar {% url 'posts:nomeDoUrl' %}

[em posts/views.py]
    def post_page(request, slug):
        post = Post.objects.get(slug=slug)
        return render(request, 'posts/post_page.html', {'post': post})
    
Quando chamada essa fun√ß√£o, vai retornar o site do respectivo post, conforme o slug passado

[em posts/templates/post_page.html]
    √â criada a estrutura do post

==================== Imagens ====================

[em setup/setting.py]
    MEDIA_URL = 'media/'

    MEDIA_ROOT = os.path.join(BASE_DIR, 'media')    

    diret√≥rio das imagens

[em setup/urls.py]
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

    basicamente dizendo para o app onde podemos encontrar imagens

dentro do ambiente (venv)
pip install Pillow

[em posts/models.py]
    foto = models.ImageField(default='Sfoto.jpg', blank=True)

    adiciona um atributo √† classe q tem uma foto default se n√£o adicionada e n√£o exige foto

[em posts/templates/post_page.html]
    <img 
        class="banner"
        src="{{ post.foto.url}}" 
        alt="{{ post.title }}"
    />

Coloca a foto embaixo do t√≠tulo e um class="banner" para adicionar personaliza√ß√£o no css

==================== Relembrando como √© o setup de um app e sua p√°gina ====================

    Apps s√£o peda√ßos de um projeto, com o intuito de diminuir a complexidade do projeto,
tipo SCRUM basicamente, mas em c√≥digo. Eles s√£o modulares, isto √©, ele s√£o como, literal,
pe√ßas, ent√£o √© poss√≠vel copiar o app de um projeto para o outro, ele funcionam independen-
mente.

py manage.py startapp 'nome do app'

[em setup/settings]
    na parte de INSTALLED_APPS, incluir 'nomedoapp', para q o django reconhe√ßa mudan√ßas
na main setup e nos apps

[em users/urls.py]
    setta os urlpatterns = []
        path('slug on ip', views.nomeFuncaoEmViews, name="nome do path")

[em setup/urls.py]
    path('users/', include('users.urls'))
    para o Django reconhecer os urls do users

[em users/views.py]
    def nomeFuncaoEmViews(request):
        return render( request, "users/paginaParaQualSeraRedirecionado.html")

Criar pasta templates no app
[em users/templates/paginaParaQualSeraRedirecionado.html]
    Copia os outros templates e muda o que for repetido

==================== Form para se registrar ====================

[em users/views.py]
    from django.contrib.auth.forms import UserCreationForm

    def register_view(request):
        form = UserCreationForm()
        return render(request, "users/paginaParaQualSeraRedirecionado.html", {"form": form} )

Basicamente estamos passando o form do view para esse html

[em users/templates/paginaParaQualSeraRedirecionado.html]
    essa "a√ß√£o" vai voltar para esse mesmo site e com que metodo vai lan√ßar esse form
    o class √© s√≥ pra enfeitar no css
    <form class="form-with-validation" action="/users/register" method="post">
        {%csrf_token%}
        {{ form }}
        <button class="form-submit">Submit</button>
    </form>

        o Django tamb√©m fornece um jeito de validar as informa√ß√µes para cadastro
    Cross Site Request Forgery (CSRF)
    para verificar se essas informa√ß√µes s√£o do nosso site ou n√£o

[em users/views.py]
    from django.shortcuts import render, redirect

        def register_view(request):
            form = UserCreationForm()
            return render(request, "users/paginaParaQualSeraRedirecionado.html", {"form": form} )

                    |
                    \/

        def register_view(request):
            if request.method == "POST":
                form = UserCreationForm(request.POST)  # o form foi enviado com informa√ß√£o
                if form.is_valid():  # se form √© valido, salva ele e redireciona para a lista de posts
                    form.save()
                    return redirect("posts:list")
            else:  # posts n√£o enviado
                form = UserCreationForm()
            return render(request, "users/paginaParaQualSeraRedirecionado.html", {"form": form} )

==================== Login e autentica√ß√£o ====================

[em users/urls.py]
    path('login/', views.login_view, name="login)

[em users/views.py]
    from django.contrib.auth.forms import UserCreationForm, AuthenticationForm

    def login_view(request):
        if request.method == "POST":
            return redirect("users:login")
        else:  # getRequest
            form = AuthenticationForm()
        
        return render(request, "users/login.html,{"form":form})

[em users/templates/login.html]        
    igual ao template padr√£o
                                                        |
    <form class="form-with-validation" action="/users/login" method="post">
        {%csrf_token%}
        {{ form }}
        <button class="form-submit">Submit</button>
    </form>

[em users/views.py]
    def login_view(request):
        if request.method == "POST":
            form = AuthenticationForm(data=request.POST)
            if form.is_valid():
                #LOGIN HERE
                return redirect("users:login")
        else:  # getRequest
            form = AuthenticationForm()
        
        return render(request, "users/login.html,{"form":form})

                |       TEST
                \/

    from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
    from django.contrub.auth import login

    def login_view(request):
        if request.method == "POST":
            form = AuthenticationForm(data=request.POST)
            if form.is_valid():
                #LOGIN HERE
                login(request, form.get_user())
                return redirect("posts:list")
        else:  # getRequest
            form = AuthenticationForm()
        
        return render(request, "users/login.html,{"form":form})

                    adicionando um variavel no registro

        def register_view(request):
            if request.method == "POST":
                form = UserCreationForm(request.POST)  # o form foi enviado com informa√ß√£o
                if form.is_valid():  # se form √© valido, salva ele e redireciona para a lista de posts
        -->         login(request, form.save())
                    return redirect("posts:list")
            else:  # posts n√£o enviado
                form = UserCreationForm()
            return render(request, "users/paginaParaQualSeraRedirecionado.html", {"form": form} )

            TESTAR -> se logado por aqui, loga tamb√©m no /admin/

==================== Autoriza√ß√£o ====================

P√°ginas protegidas para quem n√£o est√° logado

[em users/urls.py]
     path('logout/', views.logout_view, name="logout)

[em users/views.py]
    from django.contrib.auth import login, logout

    def logout_view(request):
        if request.method == "POST":
            logout(request)
            return redirect("posts:list)

[em static/style.css]

    classe logout
    .logout {
        display : inline-block;
    }

    class logout button
    .logout-button {
        font-size: 2.5rem;
        background-color: rgb(0,0,0,0);
        border: none;
    }

    .logout-button:hover {
        opacity: .75;
    }

[em templates/layout.html]
    onde coloca um novo bot√£o, este bot√£o far√° o logout

    <form class="logout" action="{ url 'users:logout' }" method="post">
        {% csrf_token %}
        <button class="logout-button" aria-label="User Logout" title="User Logout>
            emoji
        </button>
    </form>

    Criando pagina que precisa de login

[em posts/urls.py]
    √â preciso colocar em cima do <slug: slug>
    path('new-post/',views.post_new ,name="new-post")

[em posts/views.py]
    def post_new(request):
        return render(request, 'posts/post_new.html')

[em posts/template/post_new.html]
    Copia do post_page

    deleta tudo dentro de <section>
    <section>
        <h1>New Post</h1>
    </section>

[em templates/layout.html]
    <a href="{% url 'posts:new-post' %}>
        <span role="img" aria-label="New Post" title="New Post>EMOJI</span>
    </a>

    qualquer um consegue ver esse bot√£o, ent√£o agora vamos fazer com que apenas usu√°rios logados vejam esse bot√£o

[em posts/views.py]
    from django.contrib.auth.decorators import login_required

    esse @ checa se quando a fun√ß√£o executa, o user est√° logado, sen√£o manda eles pro url em parenteses
    @login_required(login_url="/user/login/")
    def post_new(request):

    ele manda para o html de login e no url aparece:
    ip/users/login/?next=/posts/new-post/
    isso quer dizer que assim que o login for efetuado, ele ser√° redirecionado para o post/new-post

[em users/templates/login.html]
    {{form}}

    {% if request.GET.next %}  se existe um request depois...
        <input type="hidden" name="next" value="{{ request.GET.next }}" />
    {% endif %} 

[em users/views.py]
    def login_view(request):
        if request.method == "POST":
            form = AuthenticationForm(data=request.POST)
            if form.is_valid():
                #LOGIN HERE
                login(request, form.get_user())
                return redirect("posts:list")                <---
        else:  # getRequest
            form = AuthenticationForm()
        
        return render(request, "users/login.html,{"form":form})

quando a gente loga, n√£o importa como, vamos para a lista de posts

    def login_view(request):
        if request.method == "POST":
            form = AuthenticationForm(data=request.POST)
            if form.is_valid():
                #LOGIN HERE
                login(request, form.get_user())
                if 'next' in request.POST:
                return redirect(request.POST.get('next') )      <--
                # 'next' nesse caso √© o valor do input no hidden do login.html
                else:
                    return redirect("posts:list")               <--

        else:  # getRequest
            form = AuthenticationForm()
        return render(request, "users/login.html,{"form":form})

Ou manda pra onde queria, ou loga e manda direto pra lista de posts

===== Barra de navega√ß√£o condicional =====

[em templates/layout.html]
    em cima dos bot√µes pra verificar se ta logado ou n√£o

    {% if user.is_authenticated %}
        novo post e logout buttons
    {% else %}
        register e login
    {% endif %}

==================== Form Personalizado ====================

[em posts/forms.py]
    from django import forms
    from . import models   -> usa o model do Post

    class CreatePost(forms.ModelForm):
        class Meta:  --> tem que ser Meta, classe aninhada dentro de CreatePost
            model = models.Post
            fields = ['title', 'body,'slug','banner'] -> o que ser√° pego dos inputs

[em posts/views.py]
    from . import forms

    def post_new(request):   -> continuar implementa√ß√£o deste metodo
        form = forms.CreatePost()
        return render(request, 'posts/post_new.html', {'form':form})

[em posts/templates/post_new.html]
    nesse html tem o padr√£o do layout +
    <section>
        <h1>New Post</h1>
    </section>

            |
            \/

    <section>
        <h1>New Post</h1>
        # class -> css , enctype -> imagem (√© do html) , url -> nome do url no app_name=posts
        <form class="form-with-validation" action="{% url 'posts:new_post' %}" method="post" enctype="multipart/form-data"
            {%csrf_token%}
            {{ form }}
            <button class="form-submit">Add Post</button>
        </form>
    </section>

[em posts/views.py]
    from django.shortcuts import render, redirect
    @login_required(login_url="/user/login/")
    def post_new(request):
        if request.method == 'POST':
            form = forms.CreatePost(requst.POST, request.FILES)
            if form.is_valid():
                # save with user
                return redirect('posts:list')
        else:
            form = forms.CreatePost()
        return render(request, 'posts/post_new.html', {'form':form})

DELETE ALL POSTS OR IT WILL BREAK;

Colocando o autor do post como o user
Rela√ß√£o de BD (1 usr pode criar, n posts)
[em posts/models.py]
    from django.contrib.auth.models import User
    class Post ...
        ...
        ...
        se esses User for deletado da tabela de Users, deleta todas os posts dele
        author = models.ForeignKey(User, on_delete=models.CASCADE, default=None)

[em posts/templates/posts_list.html]
    </h2>
    <p> {{post.date}} by {{post.author}}</p>

[em posts/views.py]
    @login_required(login_url="/user/login/")
    def post_new(request):
        if request.method == 'POST':
            form = forms.CreatePost(requst.POST, request.FILES)
            if form.is_valid():
                newpost = form.save(commit=False)    <--
                newpost.author = request.user
                newpost.save()
                return redirect('posts:list')
        else:
            form = forms.CreatePost()
        return render(request, 'posts/post_new.html', {'form':form})

==================== UPDATES ====================

[em setup/settings.py]
    1 - import os (n√£o precisa mais)

        STATIC_ROOT = BASE_DIR / 'assets'
        MEDIA_ROOT = BASE_DIR / 'media'

        STATICFILES_DIRS = [
            BASE_DIR / 'static'
        ]

        para ver se funcionou:
        py manage.py collectstatic

        Cria uma pasta nova
        [em setup/assets]


[em setup/settings.py]
    2 - DEBUG = False (para dar deploy, deixe falso)
        ALLOWED_HOSTS = ["localhost","127.0.0.1"]


[em setup/urls.py]
    3 - 
    from django.views.static import serve
    from django.urls import path, include, re_path -> regex

    # definindo um grupo para midia e outro para static
    urlpatterns = [
        re_path(r'^media/(?P<path>.*)$', serve, {'document_root': settings.MEDIA_ROOT}),
        re_path(r'^static/(?P<path>.*)$', serve, {'document_root': settings.STATIC_ROOT}),
        ...
        ...
    ]
    #urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

[em users/templates/login.html e register.html]
    4 - <form class="form-with-validation" action="{% url 'users:login' %}" method="post">
        <form class="form-with-validation" action="{% url 'users:register' %}" method="post">


========== PROJECT DEPLOYMENT ==========
Kayano
evandrok1

lucascss
css123456

yuri
ysb12345

robert
rl123456

py -m pip install django-autoslug

slug automatico para perfis